## 关于协程的几个问题

#### Q：

1. 很多[博客](https://www.jianshu.com/p/76d2f47b900d)中都有提到的一句

   > 协程是运行在单线程中的并发程序

   同时又有[博客](https://blog.csdn.net/liuyingming910/article/details/42397319)中提到

   > 高性能的程序首要注意的就是避免程序阻塞。那么，在以协程为最小运行单位的程序中，同样也需要确保这一点，即每一个协程都不能发生阻塞。因为只要某一个协程发生了阻塞，那么整个调度器就阻塞住了，后续等待的协程得不到运行，整个程序此时也将死翘翘了。

   所以协程到底是并行程序还是串行程序？

2. 所有协程被挂起后，线程内没有可执行任务，线程会被销毁吗？与阻塞有什么区别？

3. 协程内有多个 suspend，其中一个 suspend 挂起后，协程处于什么状态？

4. 协程挂起后，会恢复在哪个线程？

5. 代码执行顺序问题

   ```kotlin
   GlobalScope.launch(Dispatchers.Main) {
       println("start main scope")
       println(launchTestIO())
   }
   GlobalScope.launch(Dispatchers.IO) {
       println("continue main scope")
       println(launchTestIO())
       intercept = true
   }
   println("-------------")
   ```

   为什么输出结果顺序是反的？

   ```java
   09-23 09:47:34.965 24208-24208/com.lemay.android.book I/System.out: -------------
   09-23 09:47:34.967 24208-24436/com.lemay.android.book I/System.out: continue main scope
   09-23 09:47:35.119 24208-24208/com.lemay.android.book I/System.out: start main scope
   09-23 09:47:38.975 24208-24439/com.lemay.android.book I/System.out: exit sleep
   ```

   

#### A：

1. 产生这个问题的原因是没有搞清楚什么是[**并发**](https://www.cnblogs.com/yulinfeng/p/6845222.html)，什么是**并行**。

   > 并发是指在一段时间内同时做多个事情，比如在1点-2点洗碗、洗衣服等。而并行是指在同一时刻做多个事情，比如1点我左手画圆右手画方。两个很重要的区别就是“一段时间”和“同一时刻”.在操作系统中就是:
   >
   > - 并发就是在单核处理中同时处理多个任务.(这里的同时指的是逻辑上的同时)
   >
   > - 并行就是在多核处理器中同时处理多个任务.(这里的同时指的就是物理上的同时)

   一个线程上可以同时有多个协程，同一时间只能有一个协程被运行。一个协程进入阻塞(暂停)状态就会被挂起，执行下一个协程，直到所有协程被挂起，线程继续执行其他调用栈中其他事情。待异步事务完成，执行 resume 操作，协程正常往下执行。**协程 resume 后，如果此时有其他正在执行的协程，会等待该协程执行完成后再去执行。**

   综上，协程满足单核处理中逻辑上同时执行多个任务的概念，所以协程是单线程中的并发程序。
   
2. 所有协程被挂起，线程没有被销毁，处于存活状态。*与线程被阻塞有什么区别？（猜测区别是不占用  cpu，待后期研究）*

3. 一个协程内有多个 suspend，其中一个挂起后，整个协程都会处于挂起状态。多个协程其中一个挂起后，会按照代码顺序执行下一个协程。如果想要等待当前协程执行完成再去执行下一个协程，可以使用 async 方法进行 await，保证代码的执行顺序。

4. 只考虑  `Dispatcher.Default`、`Dispatcher.Main`、`Dispatcher.IO` 三种情况的话，只要内部协程的策略不是 `Dispatcher.Main` 都会执行在默认线程池中。（**PS：**代码注释中有一个表格）

5. > `Dispatchers.Main` 是以给主线程 `handler` 添加任务的方式现实在主线程上的运行的

   **猜测：** *`Dispatchers.Main` 调用主线程 ` handler` 将任务发送到消息队列中，而 `println("-------------")` 在队列中的位置处于任务前面，所以在其后面执行。`Dispatchers.IO` 会直接执行任务。*

